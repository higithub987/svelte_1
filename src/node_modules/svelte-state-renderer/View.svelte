<script context="module">
  import { getContext, setContext, tick } from 'svelte'

  const ROUTING = Symbol('UiView.routing')
  const REGISTER_CHILD = Symbol('UiView.registerChild')

  export const getRouterContext = () => getContext(ROUTING)

</script>

<script>
  export let asr

  let props
  let Component

  // --- Routing context ---

  if (asr) {
    setContext(ROUTING, { asr })
  } else {
    ({ asr } = getContext(ROUTING))
  }

  // --- API ---

  let child
  let childApi
  let component

  export const setComponent = async (newComponent, newProps) => {
    Component = newComponent
    props = newProps
    await tick()
    return component
  }

  // NOTE I'm pretty sure child should work here but, as a matter of fact it
  // does not (we end up with half cooked View components that don't have
  // setComponent method). Seems like a bug in Svelte.
  //
  // The workaround is, pretty ironically given the context, to use context.
  //
  // export const getChild = () => child
  export const getChild = () => childApi

  // --- Register itself to parent ---

  const register = getContext(REGISTER_CHILD)

  if (register) {
    const $destroy = () => {
      Component = null
    }

    register({ setComponent, getChild, $destroy })
  }

  // --- Expose register hook for child ---

  setContext(REGISTER_CHILD, api => {
    childApi = api
  })
</script>

{#if Component}
  <svelte:component this={Component} bind:this={component} {...props}>
    <svelte:self {asr} bind:this={child} />
  </svelte:component>
{/if}
